package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	contextPackage      = protogen.GoImportPath("context")
	rpcxServerPackage   = protogen.GoImportPath("github.com/smallnest/rpcx/server")
	rpcxClientPackage   = protogen.GoImportPath("github.com/smallnest/rpcx/client")
	rpcxProtocolPackage = protogen.GoImportPath("github.com/smallnest/rpcx/protocol")
	copierPackage       = protogen.GoImportPath("github.com/jinzhu/copier")
)

var tmp = template.Must(template.New("service").Parse(`
type {{.InterfaceName}}Client struct{
	xclient client.XClient
}

func New{{.InterfaceName}}Client(xclient client.XClient) *{{.InterfaceName}}Client {
	return &{{.InterfaceName}}Client{xclient: xclient}
}


{{range .Methods}}
func (c *{{$.InterfaceName}}Client) {{.Name}}(ctx context.Context, args *{{.Args}}) (*{{.Reply}}, error) {
	reply := &{{.Reply}}{}
	err := c.xclient.Call(ctx,"{{.Name}}",args, reply)
	return reply, err
}
{{end}}

type {{.InterfaceName}}Handler interface {
{{range .Methods}}
	{{.Name}}(context.Context, *{{.Args}}) (*{{.Reply}}, error)
{{end}}
}

type {{.StructName}}Handler struct {
	h {{.InterfaceName}}Handler
}

{{range .Methods}}
func (s *{{$.StructName}}Handler) {{.Name}}(ctx context.Context, args *{{.Args}}, reply *{{.Reply}}) error {
	resp, err := s.h.{{.Name}}(ctx, args)

	if err != nil {
		return err
	}

	err = copier.Copy(reply, resp)

	if err != nil {
		return err
	}

	return nil
}
{{end}}

func Register{{.InterfaceName}}Service(svc *server.Server, hdlr {{.InterfaceName}}Handler, metadata string) error {
	hand := &{{.StructName}}Handler{hdlr}
	return svc.RegisterName("{{.InterfaceName}}", hand, metadata)
}
`))

type TempArgs struct {
	InterfaceName string
	StructName    string
	Methods       []*Methods
}

type Methods struct {
	Name  string
	Args  string
	Reply string
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {

	if len(file.Services) == 0 {
		return nil
	}

	fileName := file.GeneratedFilenamePrefix + ".pb.rpcx.go"

	g := gen.NewGeneratedFile(fileName, file.GoImportPath)

	dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
	if err != nil {
		log.Fatal(dir, err)
	}

	g.P("//", dir)
	g.P("// Code generated by protoc-gen-rpcx. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-rpcx v", version)
	g.P("// - protoc          ", protocVersion(gen))

	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}

	g.P()
	g.P("package ", file.GoPackageName)

	g.P("var _ = ", contextPackage.Ident("TODO"))
	g.P("var _ = ", rpcxServerPackage.Ident("NewServer"))
	g.P("var _ = ", rpcxClientPackage.Ident("NewClient"))
	g.P("var _ = ", rpcxProtocolPackage.Ident("NewMessage"))
	g.P("var _ = ", copierPackage.Ident("Copy"))

	g.P()

	// fmt.Println(file.Services[0])

	for _, service := range file.Services {
		templateArgs := &TempArgs{
			InterfaceName: upperFirstLatter(service.GoName),
			StructName:    lowerFirstLatter(service.GoName),
		}

		methods := make([]*Methods, 0)

		for _, m := range service.Methods {
			name := m.GoName
			argsName := g.QualifiedGoIdent(m.Input.GoIdent)
			replyName := g.QualifiedGoIdent(m.Output.GoIdent)
			methods = append(methods, &Methods{
				Name:  name,
				Args:  argsName,
				Reply: replyName,
			})
		}

		templateArgs.Methods = methods

		buf := new(bytes.Buffer)
		tmp.Execute(buf, templateArgs)

		g.P(buf.String())
		// generateInterface(g, service)
		// genreateStruct(g, service)
	}

	return g
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func upperFirstLatter(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return strings.ToUpper(string(s[0]))
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}

func lowerFirstLatter(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return strings.ToLower(string(s[0]))
	}
	return strings.ToLower(string(s[0])) + s[1:]
}
